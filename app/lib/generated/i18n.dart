
import 'dart:async';

import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: camel_case_types
// ignore_for_file: prefer_single_quotes

//This file is automatically generated. DO NOT EDIT, all your changes would be lost.

class S implements WidgetsLocalizations {
  const S();

  static const GeneratedLocalizationsDelegate delegate =
      const GeneratedLocalizationsDelegate();

  static S of(BuildContext context) =>
      Localizations.of<S>(context, WidgetsLocalizations);

  @override
  TextDirection get textDirection => TextDirection.ltr;

  String get schedule_page__auth_dialog_message => "Sign in to save events, reserve seats and rate sessions (if an attendee). Actions will be synced from your account across app and site.";
  String get schedule_page__auth_dialog_not_now_button => "Not now";
  String get schedule_page__auth_dialog_sig_in_button => "Sign in";
  String get schedule_page__auth_dialog_title => "Sign in to customize your schedule";
}

class de extends S {
  const de();

   @override
  TextDirection get textDirection => TextDirection.ltr;

  @override
  String get schedule_page__auth_dialog_not_now_button => "Nicht jetzt";
  @override
  String get schedule_page__auth_dialog_message => "Melden Sie sich an, um Ereignisse zu speichern, Sitzplätze zu reservieren und Sitzungen zu bewerten (falls ein Teilnehmer anwesend ist). Aktionen werden von Ihrem Konto aus über App und Website synchronisiert.";
  @override
  String get schedule_page__auth_dialog_title => "Melden Sie sich an, um Ihren Zeitplan erstellen";
  @override
  String get schedule_page__auth_dialog_sig_in_button => "Anmelden";
}

class en extends S {
  const en();
}


class GeneratedLocalizationsDelegate extends LocalizationsDelegate<WidgetsLocalizations> {
  const GeneratedLocalizationsDelegate();

  List<Locale> get supportedLocales {
    return const <Locale>[

      const Locale("de", ""),
      const Locale("en", ""),

    ];
  }

  LocaleResolutionCallback resolution({Locale fallback}) {
    return (Locale locale, Iterable<Locale> supported) {
      final Locale languageLocale = new Locale(locale.languageCode, "");
      if (supported.contains(locale))
        return locale;
      else if (supported.contains(languageLocale))
        return languageLocale;
      else {
        final Locale fallbackLocale = fallback ?? supported.first;
        return fallbackLocale;
      }
    };
  }

  @override
  Future<WidgetsLocalizations> load(Locale locale) {
    final String lang = getLang(locale);
    switch (lang) {

      case "de":
        return new SynchronousFuture<WidgetsLocalizations>(const de());
      case "en":
        return new SynchronousFuture<WidgetsLocalizations>(const en());

      default:
        return new SynchronousFuture<WidgetsLocalizations>(const S());
    }
  }

  @override
  bool isSupported(Locale locale) => supportedLocales.contains(locale);

  @override
  bool shouldReload(GeneratedLocalizationsDelegate old) => false;
}

String getLang(Locale l) => l.countryCode != null && l.countryCode.isEmpty
    ? l.languageCode
    : l.toString();
